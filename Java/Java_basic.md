# 子类可以继承父类的所有成员吗？
    子类可以继承父类的所有成员，包括被private修饰的成员，子类只是无法访问、不能调用被private修饰的方法罢了。
    我们还是要分清继承和访问权限的问题。
    可以继承私有变量但是不能访问！！！！ 
    子类只能访问父类的非私有成员。
# 静态方法中，只能调用静态的方法或属性
链接：https://www.nowcoder.com/questionTerminal/e2e3f21d22a143dfb7b2396a0cd39047
来源：牛客网

class Test{
     private int m;//改称static int m;
         public static void fun() {
         // some code...
         m
    }
}

# 假设以数组Data[0..m-1]存放循环队列的元素，其头尾指针分别为front和rear，则当前队列中的元素个数为 （rear-front+m）%m
循环队列SQ的存储空间是数组d[m]，队头、队尾指针分别是front和rear，则执行出队后其头指针front值是（）： front=(front+1)%m
# 线性表是________。一个有限序列，可以为空
# 将10阶对称矩阵压缩存储到一维数组A中，则数组A的长度最少为

仅存上三角或者下三角，再加对角线
（（n-10）/ 2)+10 = 55
# char s1[10], s2[10] = {"books"};
则能将字符串 books 存放到数组 s1 的正确语句是(   )
正确答案: A   你的答案: B (错误)

strcpy(s1, s2);

s1 = {"books"};

s1 = s2;

strcpy(s2, s1);


数组名代表的是数组的首地址，是一个地址常量，所以不能给数组名赋值（函数定义的形参列表传入的是指向数组的指针变量，可以变化）C错误
# 若二维数组 a 有 m 列，则计算任一元素 a[i][j] 在数组中的位置公式为（    ）。
（假设 a[0][0] 位于数组的第一个位置上） i*m+j+1

# 假设以行优先顺序存储三维数组A[5][6][7],其中元素A[0][0][0]的地址为1100，且每个元素占2个存储单元，则A[4][3][2]的地址是()
 把三维坐标想象成立方体。分配的空间A[5][6][7]表示层高为5、行数为6、列数为7
因为数数的基本单位其实是列，二维坐标是行号列号，虽然平时可能习惯行号列号层号，但是按照二维的规律，那么三维坐标应该是层号行号列号

那么A[4][3][2]中4、3、2分别对应这个点的层数、行号、列号
位置为4*(6*7)+3*7+2=191
每个元素两个存储单元，最终结果为191*2+1100=1482 

#  线性是线性，顺序是顺序，线性是逻辑结构，顺序是存储结构，两者不是一个概念，线性是指一个元素后继只有唯一的一个元素或节点，非线性是一个元素后面可以有多个后继或前继节点，顺序是指存储结构连续，例如数组是顺序的，链表不是顺序的，但他们都是线性的。当然顺序也可以是非线性的，例如顺序结构存储非线性结构的二叉树！！！ 

常用的线性结构有：线性表，堆栈，队列，双队列，数组，串。
常见的非线性结构有：二维数组，***数组，广义表，树(二叉树等)，图。 

# pa是执行1000次1000万连续地址的相加，pb是执行1000万次1000连续地址的相加，虽然相加次数是一样的，但是pa数组较长，跨的页较多，所以会产生较多次的缺页，导致执行速度较pb慢 
	
#define NUMA 10000000
#define NUMB 1000
int a[NUMA], b[NUMB];
  
void pa()
{
    int i, j;
    for(i = 0; i < NUMB; ++i)
        for(j = 0; j < NUMA; ++j)
            ++a[j];
}
void pb()
{
    int i, j;
    for(i = 0; i < NUMA; ++i)
        for(j = 0; j < NUMB; ++j)
            ++b[j];
}
# 数组A的每个元素需要4个字节存放，数组有8行 10列，若数组以行为主顺序存放在内存SA开始的存储区中，则A中8行5列的元素的位置是
SA+296
 要求8行5列的位置，
也就是说SA需要+7行10列+1行4列，就能指到8行5列的位置处。
SA+7*10*4+1*4*4=SA+296。 
# 组的优点，查找O(1) 
# 以下二维数组声明中，正确的是（ ）。


char b[2][3]={"a","b","c"};

char b[][3]={0};

char b[2][]={0};

char b[][]={0}


    A，表示能存2字符串，每个字符串的长度不超过3，但是A中存了3个字符串，越界；
    C、D，二维数组定义时，一维大小可缺省，但二维大小必须指明确定值； 


# 一、push方法是向数组末尾添加一个或者多个元素，并返回新的长度 二、pop方法删除数组的最后一个元素，把数组的长度减1，并且返回它被删除元素的值，如果数组变为空，则该方法不改变数组，返回undefine值 三、unshift()方法是向数组的开头添加一个或多个元素，并且返回新的长度 四、shift()方法和unshift()方法恰恰相反。该方法用于把数组的第一个元素从其中删除，并返回被删除的值。如果数组是空的，shift()方法将不进行任何操作，返回undefined的值。 五,join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。

# 一个5*4的矩阵，有多少个长方形？（正方形也算是长方形）
 就像上面的表格，每一个格子可以说成是一个长方形，算的时候就是求这些边的组合：
竖着取两条边，C(6,2)。横着取两条边C(5,2)
所以结果就是：C(6,2)*C(5,2)=15*10=150  

# 二维数组是默认的存储模式是行优先存储，也就是每行的数据都是连续的，而每列的数据是不连续的，所以按行访问更快。况且这是个长宽相等的方正。

# 优先级队列和有序数组的一个区别是()
正确答案: A   你的答案: C (错误)

最低优先级别的数据项不能从数组中轻易的提取出来，而在优先级队列中可以。

数组必须是有序的，而优先级队列不需要。

最高优先级的数据项可以很容易地从优先级队列中提取出来，而有序数组不行。

其他三个选项都是。
# Name -> ID 就是 string -> int，字符串最好用 Hash 或 Tree 来索引，不过由于 Name 不是唯一的，一个 Name 可能对应多个 ID，要用 Linked List 做对应过来的结构。所以可以是 Hash + Linked List 或 Tree + Linked List。（Tree 可以用 Trie，复杂度是 O(length(name))，其实 Hash 会更好，理论上复杂度是 O(1)）。
ID -> Name 就是 int(7 digit) -> string，7 位数也就是 1000 w，可以开得下（人家机子好），所以就可以随机查了。 


# 一个非空广义表的表尾()
只能是子表
如果广义表LS=（a1,a2...an）非空，则 a1是LS的表头，其余元素组成的表（a2,a3,..an）是称为LS的表尾。 
根据定义，非空广义表的 表头是一个元素，它 可以是原子也可以是一个子表， 而表尾则必定是子表。例如:LS=(a,b),表头为a,表尾是（b）而不是b.另外：LS=（a)的表头为a，表尾为空表().
（2）非空广义表，除表头外，其余元素构成的表称为表尾，所以非空广义表尾一定是个表

# java中的数据类型分类：
     基本数据类型（或叫做原生类、内置类型）8种：
                           整数：byte，short，int，long（默认是int类型）
                           浮点类型： float，double（默认是double类型）
                           字符类型：char
                           布尔类型：boolean
      引用数据类型3种：数组，类，接口
其中，基本数据类型之间除了boolean，其他数据类型之间可以任意的相互转换（强制转化或默认转换），这个与c++中有点区别。
个人认为c定义数组的方式是正确的，只不过少了一个分号。java中定义数组有两种方式，一种是int[ ] number，一种是int  number[ ]，推荐第一种，可读性更高。


# 在一个有8个int数据的数组中，随机给出数组的数据，找出最大和第二大元素一定需要进行几次比较（     ）将8个数据俩俩分组比较，需要7次得到最大元素，假设为E，那么第二大元素的取值范围为图中的黄色部分，需要2次比较得出，所以一共是9次。

# 以下操作中，数组比链表速度更快的是____
正确答案: A C E   你的答案: E (错误)

原地逆序

头部插入

返回中间节点

返回头部节点

选择随机节点
主要解释下A选项，如果是数组只要遍历一半元素就可以了，翻转的思想类似于字符串逆序，但链表如果要完成逆序，就算只是修改指针也要把所有的元素遍历完，所以相比而言数组还是比链表快的。 
# Which statement declares a variable a which is suitable for referring to an array of 50 string objects?（Java）
 BCF 
在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度.。
如下，1，2,3可以通过编译，4，5不行。而String是Object的子类，所以上述BCF均可定义一个存放50个String类型对象的数组。
1. String a[]=new String[50];
2. String b[];
3. char c[];
4. String d[50];
5. char e[50];
# 对静态成员的不正确描述是___________静态成员函数拥有this指针
静态数据成员要在类内声明 ，类外定义和初始化 
# 3 进程的基本特性是（）。
进程是动态的、多个进程可以含有相同的程序和多个进程可以并行运行

# 静态外部变量只在本文件内可用。请问这句话的说法是正确的吗？ 正确

#  以下代码共调用多少次拷贝构造函数：	
Widget f(Widget u)
{  
   Widget v(u);
   Widget w=v;
   return w;
}
main(){
    Widget x;
    Widget y=f(f(x));
}


答案为 D 。
y=f(f(x)) 有两层 f() ，为了说明过程，把里面的一层标明为 f_1 ，外面一层标明为 f_2 。则 7 次调用分别是：
                              x  ->  f_1 的 u

f_1 的 u  ->  f_1 的 v

f_1 的 v  ->  f_1 的 w

f_1 的 w  ->  f_2 的 u

f_2 的 u  ->  f_2 的 v

f_2 的 v  ->  f_2 的 w

f_2 的 w  ->  y

# 关于ThreadLocal类 以下说法正确的是


ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本

ThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏

ThreadLocal继承Object，相当于没继承任何特殊的。
ThreadLocal没有实现任何接口。
ThreadLocal并不是一个Thread，而是Thread的局部变量。

# 下面关于静态方法说明正确的是 在静态方法中调用本类的静态方法时可直接调用


静态方法中，可以调用其他类的静态方法

静态方法中可以调用实例方法，但是必须要new一个对象

静态方法中不能用this.实例方法，因为此时对象还没有
# 以下关于运算符优先顺序的描述中正确的是（）。 赋值运算符<逻辑运算符<关系运算符<算术运算符


# 继承
     在使用抽象类时需要注意几点：

        1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。

         2、抽象方法必须由子类来进行重写。

        3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。

        4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。

        5、子类中的抽象方法不能与父类的抽象方法同名。

        6、abstract不能与final并列修饰同一个类。

        7、abstract 不能与private、static、final或native并列修饰同一个方法
        8. 如果两个类存在继承关系，则子类会自动继承父类的方法和变量，在子类中可以调用父类的方法和变量
   　　当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量。具体的原则如下：     
    　　1）能够继承父类的public和protected成员变量；不能够继承父类的private成员变量；
　　2）对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
3）对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。
　　同样地，子类也并不是完全继承父类的所有方法。
　　1）能够继承父类的public和protected成员方法；不能够继承父类的private成员方法；
　　2）对于父类的包访问权限成员方法，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
　　3）对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用
　注意：隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。
## 构造器
- 子类是不能够继承父类的构造器，但是要注意的是，如果父类的构造器都是带有参数的，则必须在子类的构造器中显示地通过super关键字调用父类的构造器并配以适当的参数列表。如果父类有无参构造器，则在子类的构造器中用super关键字调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。
- 如果子类构造函数没有显式调用超类构造函数，将会自动调用超类的无参构造函数，若超类没有无参构造函数，子类中又没有显式调用，则编译器报错
- 类A的protected修饰符的数据或方法，可以被同个包中的任何一个类访问(包括子类），也可以被不同包中的A的子类访问。
- 覆盖一个方法时，子类的方法可见性不能低于父类方法的可见性。
    （1），父类无构造函数或者一个无参数构造函数，子类若无构造函数或者有无参数构造函数，子类构造函数中不需要显式调用父类的构造函数，系统会自动在调用子类构造函数前调用父类的构造函数
   （2），父类只有有参数构造函数，子类在构造方法中必须要显示调用父类的构造函数，否则编译出错
   （3），父类既有无参数构造函数，也有有参构造函数，子类可以不在构造方法中调用父类的构造函数，这时使用的是父类的无参数构造函数
- 尤其是在多态的时候，调用一个被继承的方法，该方法访问是一个被覆盖的成员m，那么方法中到底是访问了父类的成员还是子类的成员m？结论是，若实际调用的是父类的方法，就使用了父类的该成员m,若实际调用的是子类的方法，就使用子类的成员m，记住一句，每个类使用成员都相当于在前面加了一个this指针。

## 重载重写

重载(Overloading)
（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。
重载Overloading是一个类中多态性的一种表现。
创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。
- 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。
 OOP三大特性：继承，多态，封装。
 重载的规则：
1、必须具有不同的参数列表；
2、可以有不责骂的返回类型，只要参数列表不同就可以了；
3、可以有不同的访问修饰符；
4、可以抛出不同的异常；

重写与重载的区别在于：
重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。
用好重写和重载可以设计一个结构清晰而简洁的类，可以说重写和重载在编写代码过程中的作用非同一般.
## 重写（Overriding）

（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。
  （2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。
  如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。
     （3）子类函数的访问修饰权限不能少于父类的 （public>protected>default>private）
## 2.方法覆盖：

    （1）子类覆盖父类的方法，必须有同样的参数返回类型，否则编译不能通过

    （2）子类覆盖父类的方法，在jdk1.5后，参数返回类可以是父类方法返回类的子类

    （3）子类覆盖父类方法，可以修改方法作用域修饰符，但只能把方法的作用域放大，而不能把public修改为private

      (4)子类方法能够访问父类的protected作用域成员，不能够访问默认的作用域成员

     （5）子类的静态方法不能隐藏同名的父类实例方法
4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：

父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。


     （6）java与C++一样，继承的方法具有多态性
## 3.成员覆盖：
（1）当子类覆盖父类的成员变量时，父类方法使用的是父类的成员变量，子类方法使用的是子类的成员变量

## 封装(encapsulation)
    类使得数据和对数据的操作集成在一起，从而对使用该类的其他人来说，可以不管它的实现方法，而只管用它的功能，从而实现所谓的信息隐藏。

## 多态(polymorphism)
    多态又分为设计时多态和运行时多态，例如重载又被称为设计时多态，而对于覆盖或继承的方法，JAVA运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态。总而言之，面向对象的设计的典型特点就是继承，封装和多态，这些特点也是面向对象之所以能如此盛行的关键所在。

# 接口
接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。
        1、个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！

        2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。

        3、接口中不存在实现的方法。

        4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。

        5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。

        6、在实现多接口的时候一定要避免方法名的重复。

# 抽象类与接口的区别

1、抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
2、跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已。
3、设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。
　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

2.设计层面上的区别
1）  抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。
2）  设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。
一个子类只能存在一个父类，但是可以存在多个接口。
2、在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。
3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。
# 多态

什么是多态?
多态分两种：
(1)   编译时多态（设计时多态）：方法重载。
(2)   运行时多态：JAVA运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态。（我们平时说得多的事运行时多态，所以多态主要也是指运行时多态）
运行时多态存在的三个必要条件：
一、要有继承（包括接口的实现）；
二、要有重写；
三、父类引用指向子类对象。
1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。

2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。

3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。

4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。

5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。

class A...{ 

         public String show(D obj)...{ 

                return ("A andD"); 

         }  

         public String show(A obj)...{ 

                return ("A andA"); 

         }  

}  

class B extendsA...{ 

         public String show(B obj)...{ 

                return ("B andB"); 

         } 

         public String show(A obj)...{ 

                return ("B andA"); 

         }  

} 

class C extendsB...{}  

class D extendsB...{} 


A a1 = new A(); 

A a2 = new B(); 

B b = new B(); 

C c = new C();  

D d = new D();  

System.out.println(a1.show(b));   ① ①   A and A

System.out.println(a1.show(c));   ② ②   A and A

System.out.println(a1.show(d));   ③ ③   A and D

System.out.println(a2.show(b));   ④ ④   B and A

System.out.println(a2.show(c));   ⑤ ⑤   B and A

System.out.println(a2.show(d));   ⑥ ⑥   A and D

System.out.println(b.show(b));    ⑦ ⑦   B and B

System.out.println(b.show(c));    ⑧ ⑧   B and B

System.out.println(b.show(d));    ⑨ ⑨   A and D