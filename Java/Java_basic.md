# 子类可以继承父类的所有成员吗？
    子类可以继承父类的所有成员，包括被private修饰的成员，子类只是无法访问、不能调用被private修饰的方法罢了。
    我们还是要分清继承和访问权限的问题。
    可以继承私有变量但是不能访问！！！！ 
    子类只能访问父类的非私有成员。
# 静态方法中，只能调用静态的方法或属性
链接：https://www.nowcoder.com/questionTerminal/e2e3f21d22a143dfb7b2396a0cd39047
来源：牛客网

class Test{
     private int m;//改称static int m;
         public static void fun() {
         // some code...
         m
    }
}

# 假设以数组Data[0..m-1]存放循环队列的元素，其头尾指针分别为front和rear，则当前队列中的元素个数为 （rear-front+m）%m
循环队列SQ的存储空间是数组d[m]，队头、队尾指针分别是front和rear，则执行出队后其头指针front值是（）： front=(front+1)%m
# 线性表是________。一个有限序列，可以为空
# 将10阶对称矩阵压缩存储到一维数组A中，则数组A的长度最少为

仅存上三角或者下三角，再加对角线
（（n-10）/ 2)+10 = 55
# char s1[10], s2[10] = {"books"};
则能将字符串 books 存放到数组 s1 的正确语句是(   )
正确答案: A   你的答案: B (错误)

strcpy(s1, s2);

s1 = {"books"};

s1 = s2;

strcpy(s2, s1);


数组名代表的是数组的首地址，是一个地址常量，所以不能给数组名赋值（函数定义的形参列表传入的是指向数组的指针变量，可以变化）C错误
# 若二维数组 a 有 m 列，则计算任一元素 a[i][j] 在数组中的位置公式为（    ）。
（假设 a[0][0] 位于数组的第一个位置上） i*m+j+1

# 假设以行优先顺序存储三维数组A[5][6][7],其中元素A[0][0][0]的地址为1100，且每个元素占2个存储单元，则A[4][3][2]的地址是()
 把三维坐标想象成立方体。分配的空间A[5][6][7]表示层高为5、行数为6、列数为7
因为数数的基本单位其实是列，二维坐标是行号列号，虽然平时可能习惯行号列号层号，但是按照二维的规律，那么三维坐标应该是层号行号列号

那么A[4][3][2]中4、3、2分别对应这个点的层数、行号、列号
位置为4*(6*7)+3*7+2=191
每个元素两个存储单元，最终结果为191*2+1100=1482 

#  线性是线性，顺序是顺序，线性是逻辑结构，顺序是存储结构，两者不是一个概念，线性是指一个元素后继只有唯一的一个元素或节点，非线性是一个元素后面可以有多个后继或前继节点，顺序是指存储结构连续，例如数组是顺序的，链表不是顺序的，但他们都是线性的。当然顺序也可以是非线性的，例如顺序结构存储非线性结构的二叉树！！！ 

常用的线性结构有：线性表，堆栈，队列，双队列，数组，串。
常见的非线性结构有：二维数组，***数组，广义表，树(二叉树等)，图。 

# pa是执行1000次1000万连续地址的相加，pb是执行1000万次1000连续地址的相加，虽然相加次数是一样的，但是pa数组较长，跨的页较多，所以会产生较多次的缺页，导致执行速度较pb慢 
	
#define NUMA 10000000
#define NUMB 1000
int a[NUMA], b[NUMB];
  
void pa()
{
    int i, j;
    for(i = 0; i < NUMB; ++i)
        for(j = 0; j < NUMA; ++j)
            ++a[j];
}
void pb()
{
    int i, j;
    for(i = 0; i < NUMA; ++i)
        for(j = 0; j < NUMB; ++j)
            ++b[j];
}
# 数组A的每个元素需要4个字节存放，数组有8行 10列，若数组以行为主顺序存放在内存SA开始的存储区中，则A中8行5列的元素的位置是
SA+296
 要求8行5列的位置，
也就是说SA需要+7行10列+1行4列，就能指到8行5列的位置处。
SA+7*10*4+1*4*4=SA+296。 
# 组的优点，查找O(1) 
# 以下二维数组声明中，正确的是（ ）。


char b[2][3]={"a","b","c"};

char b[][3]={0};

char b[2][]={0};

char b[][]={0}


    A，表示能存2字符串，每个字符串的长度不超过3，但是A中存了3个字符串，越界；
    C、D，二维数组定义时，一维大小可缺省，但二维大小必须指明确定值； 


# 一、push方法是向数组末尾添加一个或者多个元素，并返回新的长度 二、pop方法删除数组的最后一个元素，把数组的长度减1，并且返回它被删除元素的值，如果数组变为空，则该方法不改变数组，返回undefine值 三、unshift()方法是向数组的开头添加一个或多个元素，并且返回新的长度 四、shift()方法和unshift()方法恰恰相反。该方法用于把数组的第一个元素从其中删除，并返回被删除的值。如果数组是空的，shift()方法将不进行任何操作，返回undefined的值。 五,join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。

# 一个5*4的矩阵，有多少个长方形？（正方形也算是长方形）
 就像上面的表格，每一个格子可以说成是一个长方形，算的时候就是求这些边的组合：
竖着取两条边，C(6,2)。横着取两条边C(5,2)
所以结果就是：C(6,2)*C(5,2)=15*10=150  

# 二维数组是默认的存储模式是行优先存储，也就是每行的数据都是连续的，而每列的数据是不连续的，所以按行访问更快。况且这是个长宽相等的方正。

# 优先级队列和有序数组的一个区别是()
正确答案: A   你的答案: C (错误)

最低优先级别的数据项不能从数组中轻易的提取出来，而在优先级队列中可以。

数组必须是有序的，而优先级队列不需要。

最高优先级的数据项可以很容易地从优先级队列中提取出来，而有序数组不行。

其他三个选项都是。
# Name -> ID 就是 string -> int，字符串最好用 Hash 或 Tree 来索引，不过由于 Name 不是唯一的，一个 Name 可能对应多个 ID，要用 Linked List 做对应过来的结构。所以可以是 Hash + Linked List 或 Tree + Linked List。（Tree 可以用 Trie，复杂度是 O(length(name))，其实 Hash 会更好，理论上复杂度是 O(1)）。
ID -> Name 就是 int(7 digit) -> string，7 位数也就是 1000 w，可以开得下（人家机子好），所以就可以随机查了。 


# 一个非空广义表的表尾()
只能是子表
如果广义表LS=（a1,a2...an）非空，则 a1是LS的表头，其余元素组成的表（a2,a3,..an）是称为LS的表尾。 
根据定义，非空广义表的 表头是一个元素，它 可以是原子也可以是一个子表， 而表尾则必定是子表。例如:LS=(a,b),表头为a,表尾是（b）而不是b.另外：LS=（a)的表头为a，表尾为空表().
（2）非空广义表，除表头外，其余元素构成的表称为表尾，所以非空广义表尾一定是个表

# java中的数据类型分类：
     基本数据类型（或叫做原生类、内置类型）8种：
                           整数：byte，short，int，long（默认是int类型）
                           浮点类型： float，double（默认是double类型）
                           字符类型：char
                           布尔类型：boolean
      引用数据类型3种：数组，类，接口
其中，基本数据类型之间除了boolean，其他数据类型之间可以任意的相互转换（强制转化或默认转换），这个与c++中有点区别。
个人认为c定义数组的方式是正确的，只不过少了一个分号。java中定义数组有两种方式，一种是int[ ] number，一种是int  number[ ]，推荐第一种，可读性更高。


# 在一个有8个int数据的数组中，随机给出数组的数据，找出最大和第二大元素一定需要进行几次比较（     ）将8个数据俩俩分组比较，需要7次得到最大元素，假设为E，那么第二大元素的取值范围为图中的黄色部分，需要2次比较得出，所以一共是9次。

# 以下操作中，数组比链表速度更快的是____
正确答案: A C E   你的答案: E (错误)

原地逆序

头部插入

返回中间节点

返回头部节点

选择随机节点
主要解释下A选项，如果是数组只要遍历一半元素就可以了，翻转的思想类似于字符串逆序，但链表如果要完成逆序，就算只是修改指针也要把所有的元素遍历完，所以相比而言数组还是比链表快的。 
# Which statement declares a variable a which is suitable for referring to an array of 50 string objects?（Java）
 BCF 
在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度.。
如下，1，2,3可以通过编译，4，5不行。而String是Object的子类，所以上述BCF均可定义一个存放50个String类型对象的数组。
1. String a[]=new String[50];
2. String b[];
3. char c[];
4. String d[50];
5. char e[50];
# 对静态成员的不正确描述是___________静态成员函数拥有this指针
静态数据成员要在类内声明 ，类外定义和初始化 
# 3 进程的基本特性是（）。
进程是动态的、多个进程可以含有相同的程序和多个进程可以并行运行

# 静态外部变量只在本文件内可用。请问这句话的说法是正确的吗？ 正确

#  以下代码共调用多少次拷贝构造函数：	
Widget f(Widget u)
{  
   Widget v(u);
   Widget w=v;
   return w;
}
main(){
    Widget x;
    Widget y=f(f(x));
}


答案为 D 。
y=f(f(x)) 有两层 f() ，为了说明过程，把里面的一层标明为 f_1 ，外面一层标明为 f_2 。则 7 次调用分别是：
                              x  ->  f_1 的 u

f_1 的 u  ->  f_1 的 v

f_1 的 v  ->  f_1 的 w

f_1 的 w  ->  f_2 的 u

f_2 的 u  ->  f_2 的 v

f_2 的 v  ->  f_2 的 w

f_2 的 w  ->  y

# 关于ThreadLocal类 以下说法正确的是


ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本

ThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏

ThreadLocal继承Object，相当于没继承任何特殊的。
ThreadLocal没有实现任何接口。
ThreadLocal并不是一个Thread，而是Thread的局部变量。

# 下面关于静态方法说明正确的是 在静态方法中调用本类的静态方法时可直接调用


静态方法中，可以调用其他类的静态方法

静态方法中可以调用实例方法，但是必须要new一个对象

静态方法中不能用this.实例方法，因为此时对象还没有
# 以下关于运算符优先顺序的描述中正确的是（）。 赋值运算符<逻辑运算符<关系运算符<算术运算符