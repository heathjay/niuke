       原型模式主要包含如下三个角色：

       Prototype：抽象原型类。声明克隆自身的接口。
       ConcretePrototype：具体原型类。实现克隆的具体操作。
       Client：客户类。让一个原型克隆自身，从而获得一个新的对象。

      我们都知道Object是祖宗，所有的Java类都继承至Object，而Object类提供了一个clone()方法，该方法可以将一个java对象复制一份，因此在java中可以直接使用clone()方法来复制一个对象。但是需要实现clone的Java类必须要实现一个接口:Cloneable.该接口表示该类能够复制且具体复制的能力，如果不实现该接口而直接调用clone()方法会抛出CloneNotSupportedException异常。如下：



        Java中任何实现了Cloneable接口的类都可以通过调用clone()方法来复制一份自身然后传给调用者。一般而言，clone()方法满足：
      (1) 对任何的对象x，都有x.clone() !=x，即克隆对象与原对象不是同一个对象。
      (2) 对任何的对象x，都有x.clone().getClass()==x.getClass()，即克隆对象与原对象的类型一样。
      (3) 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。

四、模式优缺点
优点

      1、如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。

      2、可以使用深克隆保持对象的状态。

      3、原型模式提供了简化的创建结构。
缺点 

      1、在实现深克隆的时候可能需要比较复杂的代码。

      2、需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。
五、模式使用场景

      1、如果创建新对象成本较大，我们可以利用已有的对象进行复制来获得。

      2、如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。
      3、需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。
六、模式总结

      1、原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。

      2、克隆分为浅克隆和深克隆两种。

      3、我们虽然可以利用原型模式来获得一个新对象，但有时对象的复制可能会相当的复杂，比如深克隆。