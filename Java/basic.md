# 下列网络设备中，能够抑制网络风暴的是() 仅IV
I中断器
II集线器
III网桥
IV路由器 
# 下述说法中______是正确的。EPROM是可改写的，但它不能用作为随机存储器用
EPROM是可擦除可编程的只读存储器．可以反复改写，但每次改写之前都需要擦除干净后，再在特殊环境下进行改写，而随机存储器要求可以随时读写，而且速度要求很快，所以不能当做随机存储器用，

# 下面关于端口镜像,链路汇聚的功能描述错误的是？
D 端口镜像（port Mirroring)把交换机一个或多个端口（VLAN）的数据镜像到一个或多个端口的方法。为了方便对一个或多个网络接口的流量进行分析（如 IDS 产品、网络分析仪等），可以通过配置交换机来把一个或多个端口（VLAN）的数据转发到某一个端口来实现对网络的监听，是网络通信协议的一种方式。这些流量就可以被一个特殊的设备监控。它对发现和修理故障有很大的帮助。 A正确，D错误 链路聚合，是将多个端口聚合在一起形成1个汇聚组，以实现出/ 入负荷在各成员端口中的分担，链路聚合后，逻辑链路的带宽增加了大约(n-1)倍，这里，n为聚合的路数。另外，聚合后，可靠性大大提高。 BC正确 

# 对于以下说法，错误的是________。找出n个数字的中位数至少需要O(n*logn)的时间

C.利用顺序统计思路找出n个数字的中位数可以再O(n)时间内完成，所以C错误。
不过对于A而言， Dijkstra求解图最短路径的复杂度与所选的数据结构有关，如果用数组，则为O(n^2)，若选用二叉堆，则为O(elogn)，若选用Fibonacci堆，则为O(e+nlogn)，所以个人感觉A的说法也不准确。
# 下列叙述正确的是
每次I/0操作都会有对应I/O请求包
每次I/0请求都对应一个I/O请求包
一次I/0请求对应一个I/O请求包
# 以下哪种技术属于高速计算机网络技术


10BASE-T

ATM

FDDI

# CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。


# 抽象类和接口的比较
1. 对类更高的抽象。
2. 这个中间产品已经实现了系统的部分功能，
3. 抽象类不能被实例化。
4. 用abstract关键字来修饰一个方法时，这个方法就是抽象方法，抽象方法不能有主体【即不能实现】；用abstract关键字来修饰一个类时，这个类就叫抽象类。
5. 抽象类不一定要包含abstract方法。也就是说抽象类可以没有abstract方法；但是一旦类包含了abstract方法，则这个类必须声明为abstract。

接口：
1. 规范，耦合的标准，通信的标准，没有内容的方法，到某个类需要使用的时候，再根据具体情况写出来。
2. 更加抽象的抽象类，抽象类中可以有非抽象的方法，接口里所有的方法都没有方法体，
3. 接口体现了程序设计的多态和高内聚低耦合的设计思想。
4. 一个类可以实现多个接口
5. 接口中可以有变量，但变量不能用private和protected修饰。
6. 接口中的变量是public, static, final 相当于全局变量，接口定义变量时必须初始化。接口的变量都是static 的不管加不加static修饰。
7. 接口不能继承其他类但能继承接口
8. 接口没有方法就可以作为标志，比如Serializable,没有方法的接口成为空接口

## 比较
1. 都不能实例化，位于继承最顶端，包含抽象方法，子类必须实现
2. 区别： 接口没有普通属性，只有静态属性 public final static 修饰; 抽象类可以有普通属性，也可以有静态属性（类属性）
3. 方法： 接口中的方法都没有方法体并且都是默认使用public abstract修饰的，不能定义静态方法，而抽象类可以有普通方法，也可以没有抽象方法，也可以定义静态方法
4. 构造函数： 接口中没有构造器，抽象类中可以有构造器，但他不能用于new对象，而是用于子类调用初始化抽象类的操作
5. 初始化块： 接口中不能包含初始化块，而冲向方法中可以包含
6. 一个类只能有一个直接父类但可以实现多个接口

# 构造方法
1. 没有返回值
2. 子类构造方法默认先调用父类无参数构造方法，若父类自定义构造方法，而子类没有使用super则会报错
3. Object.clone() 创建并返回此对象的一个副本。“副本”的准确含义可能依赖于对象的类。一般情况下：x.clone().equals(x)为true，但这并非必须要满足的要求。首先，使用这个方法的类必须实现java.lang.Cloneable接口，否则会抛出CloneNotSupportedException异常。Cloneable接口中不包含任何方法，所以实现它时只要在类声明中加上implements语句即可。第二个比较特殊的地方在于这个方法是protected修饰的，覆写clone()方法的时候需要写成public，才能让类外部的代码调用。按照惯例，返回的对象应该通过调用super.clone获得。如果一个类及其所有的超类（Object除外）都遵守此约定，则 x.clone().getClass() == x.getClass()。
4. 浅拷贝： 如果一个对象内部还有一个引用类型的基本变量，那么在拷贝该对象的时候，只是在通过clone方法新产生的新对象中拷贝一个该基本类型的引用。换句话说，也就是新对象和原对象他们内部都含有一个指向同一对象的引用。
5. 深拷贝：拷贝对象的时候，如果对象内部含有一个引用类型的变量，那么就会再将该引用类型的变量指向的对象复制一份，然后引用该新对象。
6. Java对象并不是由构造器创建的，而是由new运算符创建的，在程序运行时，是new运算符在堆上开辟一块空间，然后执行对象的初始化（其中包括调用构造器），当对象创建成功，也是new运算符将对象的起始地址返回给应用程序的（并非构造器）。
7. 构造器的作用是在对象创建的时候进行类中成员变量的初始化，
8. 因此程序执行的顺序是，先创建对象，然后求解构造器所有形参表达式的值（若形参表达式的计算出现异常，则不会调用构造器方法），最后调用构造器对对象进行初始化。

# Java 内部类
定义在另一个类内部的类：
1. 内部类的方法可以访问该类定义所在的作用域中的数据，包括私有数据
2. 内部类能够隐藏起来，不被同一个包中的其他的类所见
3. 想要定义个回调函数，且不想编写大量代码时，使用匿名内部类比较方便
4. 有四种： 成员内部类， 局部内部类，静态内部类，匿名内部类
## 成员内部类
1. 访问所有外部类的所有属性和方法，private
2. 外围访问内部类需要实例化，
3. 如果在内部类中定义有和外部类同名的实例变量，访问：OuterClass.this.outerMember;
4. 成员内部类中不能存在任何static的变量和方法（因为需要先创建外部类，才能创建自己，可以声明static的常量）
5. 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。
## 局部内部类
1. 嵌套在方法和作用域内的，
2. 想创建一个类来辅助我们的解决方案，但又不希望这个类是公共可用的，
3. 局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。
4. 局部内部类可以访问的外部类的成员根据所在方法体不同。如果在静态方法中：可以访问外部类中所有静态成员，包含私有；
5. 如果在实例方法中：可以访问外部类中所有的成员，包含私有。
6. 局部内部类可以访问所在方法中定义的局部变量，但是要求局部变量必须使用final修饰。
## 匿名内部类
1. 匿名内部类是没有访问修饰符的，也是唯一一种没有构造方法的类。
2. new 匿名内部类，这个类首先是要存在的。
3. 注意当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。

## 静态内部类（静态嵌套类）
1. 使用static修饰的内部类我们称之为静态内部类，或者称之为嵌套内部类。
2. 我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有
3. 它的创建是不需要依赖于外围类的。
4. 它不能使用任何外围类的非static成员变量和方法。

# 枚举类
1. 使用的是enum关键字
2. 有限多个, 所有的enum变量必须定义在枚举类的第一行，用逗号隔开，定义完所有的变量后，以分号结束，如果只有枚举变量，而没有自定义变量，分号可以省略。枚举变量最好大写，在其他类中使用enum变量的时候，只需要【类名.变量名】就可以了，和使用静态变量一样。
3. 默认添加public static final修饰。
4. enum类可以把它看成一个普通类，可以有构造器，成员方法，成员变量。当然和普通类也有一定的区别：
    - 枚举类的构造方法默认使用private修饰，且只能使用private修饰；
    - 枚举类默认继承自Enum类，所以不能继承其他类，Enum类实现了Serializable、Comparable接口；
    - 枚举类默认使用final修饰，因此不能派生子类。如果需要扩展enum中的元素，在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组。达到将枚举元素进行分组的目的。
    - switch()参数可以使用enum
    - enum允许程序员为eunm实例编写方法。所以可以为每个enum实例赋予各自不同的行为。
    - 常用方法
## 枚举类方法：
- valueOf()方法：它的作用是传来一个字符串，然后将它转变为对应的枚举变量。前提是你传的字符串和定义枚举变量的字符串一模一样，区分大小写。如果你传了一个不存在的字符串，那么会抛出异常。
-  values()方法：这个方法会返回包括所有枚举变量的数组，可以方便的用来做循环
- name()方法：它和toString()方法的返回值一样，这两个方法的默认实现是一样的，唯一的区别是，你可以重写toString方法。name变量就是枚举变量的字符串形式。
## 枚举变量方法：
- toString()方法：该方法直接返回枚举定义枚举变量的字符串。
- ordinal()方法：默认情况下，枚举类会给所有的枚举变量一个默认的次序，该次序从0开始，类似于数组的下标。而.ordinal()方法就是获取这个次序（或者说下标）。枚举类中枚举变量的次序可以自定义。
- compareTo()方法（枚举类实现了Comparable接口）：该方法用来比较两个枚举变量的”大小”，实际上比较的是两个枚举变量的次序，返回两个次序相减后的结果，如果为负数，就证明变量1”小于”变量2 （变量1.compareTo(变量2)，返回【变量1.ordinal()- 变量2.ordinal()】）。


Java I/O 底层细节，注意是底层细节，而不是怎么用
如何实现分布式缓存
浏览器的缓存机制
JVM tomcat 容器启动，jvm 加载情况描述 当获取第一个获取锁之后，条件不满足需要释放锁应当怎么做?
HasnMap 实现原理，扩容因子过大过小的缺点，扩容过程 采用什么方法能保证每个 bucket 中的数据更均匀 解决冲突的方式，还有没有其他方式(全域哈希)
Collection 集合类中只能在 Iterator 中删除元素的原因
java 地址和值传递的例子
java NIO，java 多线程、线程池，java 网络编程解决并发量，
java 的 I/O
手写一个线程安全的生产者与消费者。
ConcurrentHashMap 和 LinkedHashMap 差异和适用情形
ConcurrentHashMap 分段锁是如何实现的
ConcurrentHashmap jdk1.8 访问的时候是怎么加锁的，插入的时候是怎么加锁的 访问不加 锁插入的时候对头结点加锁
ArrayDeque 的使用场景
JDBC连接的过程 手写jdbc连接过程
可重入锁,实现原理
Java IO 模型(BIO,NIO 等) Tomcat 用的哪一种模型
ArrayBlockingQueue 源码
多进程和多线程的区别
说出三个遇到过的程序报异常的情况
Java 无锁原理
hashmap 和 treemap 的区别
rehash 过程
网络编程的 accept 和 connect，
HashMap 的负载因子
 .try catch finally 可不可以没有 catch(try return,finally return)
mapreduce 流程 如何保证 reduce 接受的数据没有丢失，数据如何去重 mapreduce 原理， partion 发生在什么阶段
直接写一个 java 程序，统计 IP 地址的次数
讲讲多线程，多线程的同步方法
list,map,set 之间的区别
socket 是靠什么协议支持的
java io 用到什么设计模式
serviable 的序列化，其中 uuid 的作用
什么时候会用到 HashMap
什么情景下会用到反射(答注解、Spring 配置文件、动态代理) 浅克隆与深克隆有什么区别
如何实现深克隆
常见的线程安全的集合类
Java 8 函数式编程
回调函数，函数式编程，面向对象之间区别
Java 8 中 stream 迭代的优势和区别? 同步等于可见性吗?保证了可见性不等于正确同步，因为还有原子性没考虑。
还了解除 util 其他包下的 List 吗?CopyOnWriteArrayList 反射能够使用私有的方法属性吗和底层原理?
处理器指令优化有些什么考虑? 禁止重排序
object 对象的常用方法
Stack 和 ArrayList 的区别
statement 和 prestatement 的区别
手写模拟实现一个阻塞队列
怎么使用父类的方法
util 包下有哪几种接口
cookie 禁用怎么办
Netty
new 实例化过程
socket 实现过程，具体用的方法;怎么实现异步 socket.
很常见的 Nullpointerexception ，你是怎么排查的，怎么解决的; Binder 的原理
C++/JAVA/C 的区别
java 线程安全都体现在哪些方面，如果维护线程安全 如果想实现一个线程安全的队列，可以怎么实现?
JUC包里的ArrayBlockingQueue 还有LinkedBlockingQueue啥的又结合源码说了一通。
静态内部类和非静态内部类的区别是什么?怎么创建静态内部类和非静态内部类? 。
断点续传的原理
Xml 解析方式，原理优缺点 数据缓存处理 四大组件生命周期
Java 和 JavaScript 的区别
信号量
静态变量和全局变量的区别