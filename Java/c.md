#  swap（）只是交换了全局定义的x和y，对主函数重新定义的x，y不影响。注意看x,y定义的位置。 
int x=5,y=7;
void swap ()
{    int z;
     z=x;
     x=y;
   y=z
}
int main (void)
{   
    int x=3,y=8;   
    swap();
    printf ("%d,%d\n"，x,y) ;
}


# 析构函数调用顺序
C c;
void main()
{
    A*pa=new A();
    B b;
    static D d;
    delete pa;
} 
设已经有AB,C,D4个类的定义，程序中ABCD析构函数调用顺序为?首先一个个的分析
对于类A,是建立在堆上的对象指针pa,手动释放
对于类B,是建立在栈上的对象 eb, main函数结束就释放
对类C在静态存储区创建了一个对象c程序结束时候释放
对类D也是在静态存储区建立对象d但是局部变量程序结束时候释放析构函数调用顺序
先调用A的析构因为 delete pa.A
再释放栈上的对象b
关键看CD的顺序
c是全局对象对它的初始化是在main函数之前所以析构时候要放在最后也就是先析构d,然后再析构c

# 优先级
前置++或-- 的优先级别 比 * 要高，不行就查一下运算符优先级表 
# 在下列语句中，正确的是( )。
正确答案: D   你的答案: B (错误)

char a [3] []= { 'abc','i'};

char a[] [3]={'abc','i'};

char a[3] []= {'a',"i"};

char a[] [3]={"a","i"};

# 声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*，正确的是（）
int (*(*p)[10])(int *)
C.   首先题目说要声明一个数组指针,  一般我们想到的数组指针是 随便来一个 int(*p)[10],    然后又说每个元素是一个函数指针,那么我们随便来一个 函数指针  int (*pf)(int *) . 然后把(*p)[10]作为一个整体替代 pf     即   int(*(*p)[10]))(int *);    分析: 判断一个复杂式子看最高优先级的,*p是一个指针,然后(*p)外面是[],所以是数组指针,(*p)[10])描述完毕,然后再看外面int(*)(int *)很明显,这是一个函数指针,所以这个数组中每个元素是函数指针
# 下列说法正确的是（）
对于选项c,因为数组也可以用来存储完全二叉树。 

# 义语句"double * array [8]"的含义正确的是（）。
array是一个数组，数组的每一个元素是指向双精度实型数据的指针
# 下列给定程序中，函数fun的功能是:进行数字字符转换。若形参ch中是数字字符'0'～'9',则将'0'转换成'9','1'转换成'8', '2'转换成'7',…, '9'转换成'0';如果是其他字符则保持不变，并将转换后的结果作为函数值返回。请在程序的下画线处填入正确的内容并将下画线删除，使程序得出正确的结果。试题程序。 
#include<stdio.h>
_____ fun(char ch)
{
    if(ch>='0'&& _______)
        return'9'-(ch- ______);
    return ch;
}
main( )
{ 
    char c1,c2;
    printf("\nThe result:\n");
    c1='2';
    c2=fun(c1);
    printf("c1=%c c2=%c\n",c1,c2);
    c1='8';
    c2=fun(c1);
    printf("c1=%c c2=%c\n",c1,c2);
    c1='a';
    c2=fun(c1);
    printf("c1=%c c2=%c\n",c1,c2);
}
 这题不严谨，AB输出结果都对。反正都要做类型转换，也无所谓哪个比较优

A、返回char，那么if条件里面做了隐式类型转换：int数字转成char

B、返回int，那么main中赋值给char变量的时候做了类型转换，int转char
复制代码
int fun(char ch)
{
    if(ch>='0'&& ch<='9')
        return'9'-(ch-'0');
    return ch;
}

# interface{}是可以指向任意对象的Any类型,这一说法是否正确。true
#  golang支持goto语句，这一说法是否正确。true

# 静态联编和动态联编。

通常来说联编就是将模块或者函数合并在一起生成可执行代码的处理过程，同时对每个模块或者函数调用分配内存地址，并且对外部访问也分配正确的内存地址，它是计算机程序彼此关联的过程。按照联编所进行的阶段不同，可分为两种不同的联编方法：静态联编和动态联编。

静态联编是指在编译阶段就将函数实现和函数调用关联起来，因此静态联编也叫早绑定，在编译阶段就必须了解所有的函数或模块执行所需要检测的信息，它对函数的选择是基于指向对象的指针（或者引用）的类型，C语言中，所有的联编都是静态联编,并且任何一种编译器都支持静态联编。

动态联编是指在程序执行的时候才将函数实现和函数调用关联，因此也叫运行时绑定或者晚绑定，动态联编对函数的选择不是基于指针或者引用，而是基于对象类型，不同的对象类型将做出不同的编译结果。C++中一般情况下联编也是静态联编，但是一旦涉及到多态和虚拟函数就必须要使用动态联编了。下面将介绍一下多态。

多态：字面的含义是具有多种形式或形态。C++多态有两种形式，动态多态和静态多态；动态多态是指一般的多态，是通过类继承和虚函数机制实现的多态；静态多态是通过模板来实现，因为这种多态实在编译时而非运行时，所以称为静态多态。


# 优先级
 C语言常用运算符的优先级口诀是：“单算关逻条赋逗”；
如果加入位运算符，完整口诀是：“单算移关与，异或逻条赋”。
■“单”表示单目运算符：逻辑非(!),按位取反(~),自增(++),自减(--),取地址(&),取值(*)；
■“算”表示算术运算符：乘、除和求余(*,/,%)级别高于加减(+,-)；
■“移”表示按位左移(<<)和位右移(>>)；
■“关”表示关系运算符：大小关系(>,>=,<,<=)级别高于相等不相等关系(==,!=)；
■“与”表示按位与(&)；
■“异”表示按位异或(^)；
■“或”表示按位或(|)；
■“逻”表示逻辑运算符：逻辑与(&&)级别高于逻辑或(||)；
■“条”表示条件运算符(? :)；
■“赋”表示赋值运算符(=,+=,-=,*=,/=,%=,>>=,<<=,&=,^=, |=,!=)； 